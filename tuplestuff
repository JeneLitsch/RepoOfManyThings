#include <tuple>
#include <string>
#include <iostream>

template<typename T>
auto process(auto fx, const T & t) {
    return std::make_tuple(fx(t));
}

template<typename T, typename... Ts>
auto process(auto fx, const T & t, const Ts & ...ts) {
    const auto t1 = process<T>(fx, t);
    const auto t2 = process<Ts...>(fx, ts...);
    return std::tuple_cat(t1, t2);
}

template<std::size_t I, typename...Ts>
auto pr(const auto & fx, const auto & tuple) {
    if constexpr(I == static_cast<std::size_t>(std::tuple_size<decltype(tuple)>)) {
        return std::tuple<>();
    }
    else {
        const auto t1 = std::make_tuple(fx(std::get<I>(tuple)));
        const auto t2 = pr<I+1>(fx, tuple);
        return std::tuple_cat(t1, t2);
    }
}

auto pr(const auto & fx, const auto & tuple) {
    return pr<0>(fx, tuple);
}

int main() {
    const auto fx = [] (const auto & e) { return std::string(e); };
    auto t1 = std::make_tuple("Hello", "World");
    const auto t = pr(fx, t1);
    std::cout << std::get<0>(t) << "\n";
    std::cout << std::get<1>(t) << "\n";
    return 0;
}
